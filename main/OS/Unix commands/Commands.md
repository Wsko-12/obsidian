
`whoami`
выводит текущего пользователя

`man <command>`
выводит мануал для команды
пример: `man whoami`

`pwd`
выводит текущую рабочую директорию

`ls`
выводит структуру текущей рабочей директории 
`ls -a` вдобавок выводит файлы, начинающиеся с `.`
`ls -l` выводит дополнительную информацию о файлах

`cd`
меняет текущую директорию 

`mkdir`
создает новую директорию
если попытаемся создать директорию внутри той, что не существует, будет выброшено исключение. Для этого используется флаг `mkdir -p notExistedDir/dir`

`touch`
меняет таймстемп последней модификации у файла. Если файла не существует, то создает его

`rmdir`
удаляет директорию

`rm`
удаляет директорию и (или) файл
Для того, чтобы удалить директорию с файлами используется флаг `-r` (recursive)
Можно использовать интерактивный режим `-i`, чтобы каждый раз переспрашивал, нужно ли удалять файл

`mv <source> <distination>`
перемещает файл в указанный distination
может так же использоваться для переименования фалов/папок

`cp <source> <distination>`
копирует source в distination

`head`
показывает первые 10 строк файла
кол-во строк можно увеличить флагом `-n 20`

`tail`
показывает последние 10 строк файла
кол-во строк можно увеличить флагом `-n 20`
можно использовать флаг `-f` (follow), чтобы смотреть за изменениями файла, например как логи

`cat <...files>`
конкатенирует файлы и выводит их в stdout. См. `>`

`>` редиректит stdout
Пример: `cat 1.txt > 2.txt` "выводит" 1.txt в 2.txt, однако, весь контент в 2.txt будет перезаписан
Чтобы контент не перезаписался, а добавился, используется `>>`
Если файла не существует, то создаст его
`cat 1.txt 2.txt > 3.txt` запишет весь контент 1 и 2 в 3
если вызвать с одним и тем же файлом, то останется пустой файл
`-n` показывает номера строк

`less <filename>`
выводит файл в более удобный UI, с пагинацией и тд

`echo <arg>`
выводит аргумент

`wc`
выводит кол-во строк, слов и кол-во байтов для файла. Можно дополнительными флагами вывести кол-во символов и тд

`|` оператор для пайпинга. Берет stdout команды слева и использует ее как аргумент для команды справа
Пример, у нас есть лист:
``` 
// list.txt

one 
two 
three
```

Мы можем вывести кол-во итемов в этом списке используя 
`cat list.txt | wc -l`

`sort`
сортирует строки в инпуте
если хотим отсортировать строки с числами, следует использовать `-n`
`-u`  выводит только уникальные строки

`uniq`
выводит строку, если перед ней не такая же строка
Пример:
```
aaa
bbb
aaa
ccc
ccc
ddd
```
выведет 
```
aaa
bbb
aaa
ccc
ddd
```
Т.е. убрать дублирующуюся **подряд** строку `ccc`

Специальные символы:
`*` символ, заменяющий любое кол-во символов. Пример: `echo *.txt` выведет все `txt` файлы.

`?` символ, заменяющий один символ. Пример: `echo ?est` выведет файлы `test rest`

`{}` сделает перебор значений внутри себя. Пример: `touch app.{js, html, css}` создаст файлы `app.css  app.html  app.js`. Так же можно сделать range: `echo {1..9}` выведет значения от 1 до 9


`diff`
находит разницу между двумя файлами
```
// 1.txt
aaa
bbb
ccc
ddd
```

```
// 2.txt
aaa
bbc
ccc
ddd
```

```
diff 1.txt 2.txt

2c2 // вторая строка
< bbb
---
> bbc
```

```
diff -y 1.txt 2.txt

aaa                                                             aaa
bbb                                                           | bbc
ccc                                                             ccc
ddd                                                             ddd

```

```
diff -u 1.txt 2.txt

--- 1.txt       2025-04-06 12:01:49.292489188 +0300
+++ 2.txt       2025-04-06 12:02:23.821669592 +0300
@@ -1,4 +1,4 @@
 aaa
-bbb
+bbc
 ccc
 ddd
```


`find`
Рекурсивно ищет файл во всех директориях
`find . -name '*.js'` найдет все файлы начиная с текущей директории `.` , в имени которого содержится `.js`
`find . -name 'E*' -or -name 'F*'` будет искать все вхождения, где имя начинается на E или на F
`find . -type d ` будет искать только директории
`find . -type f -exec cat {} \;` найдет все файлы и для каждого файла вызовет `cat`, где `{}` заменится на название файла (`{} \;`)


`grep <pattern> <source>` 
выводит найденый pattern в source
`grep document.createElement test.js` будет искать `document.createElement` в `test.js`


`du`
показывает занимаемое место файлом на диске (disc usage) 
`du -h | sort -h` выведет размер все фалов в human readable формате и отсортирует по возрастанию

`df`
отчет об использовании пространства файловой системы

`history`
выводит историю вводимых команд
команду по номеру можно будет вызвать еще раз используя `!`. Пример: `!203`

`ps`
Показывает информацию о текущих просессах 

`top`
показывает в real-time информацию о процессах, сколько они занимают CPU и память

`kill <PID>` 
Посылает сигнал процессу для того, чтобы остановить его

`killall <name>`
убивает все процессы по имени команды, например `killall node` убьет все процессы запущенные nodejs


`jobs`
Когда мы запускаем команду, мы можем приостановить ее выполнение используя ctrl+Z

например, выполним `top` и нажмем там `ctrl+Z`

Теперь, введем `jobs` и увидим
```
[1]+  Stopped                 top
```

Можно вернутся к ней вызвав команду `fg <COMMAND NUMBER>`, то есть `fg 1` (foreground)

Так же, не используя ctrl+Z мы можем запустить команду сразу в этом режиме используя `&`
`top &`

Например, мы запустили какую-то команду, которая выполняется очень долго.
Мы можем приостановить ее через ctrl+z, а затем продолжить ее выполнение в bg используя `bg 1`
Либо запустить ее сразу в background используя `&`


`gzip`
сжимает файл. Флаг `-k` не удаляет оригинальный файл
флаг `-d` это decompress, но можно использовать команду `gunzip`. 


`tar`
Используется, чтобы собрать файлы в один ахрив. Позже этот архив можно сжать используя `gzip`, либо сразу, используя флаг `-z`

`tar -cf archive.tar file1 file2` - создает archive.tar
`tar -czf archive.tar.gz file1 file2`  - создаст сжатый архив
`tar -xf archive.tar.gz` - разожмет и разархивирует архив (-x -- extract)


`nano` 
открывает в файл в text editor

`alias`
выводи все алиасы созданные пользователем
чтобы создать alias используется `alias mycomand='ls -la'`
Однако, он создаться только для текущей сессии терминала
Поэтому, надо добавить его в `.bash_aliases` файл
Только нужно правильно ставить кавычки:

Be careful with quotes if you have variables in the command: if you use double quotes, the variable is resolved at definition time. If you use use single quotes, it's resolved at invocation time. Those 2 are different:

```bash
alias lsthis="ls $PWD"
alias lscurrent='ls $PWD'
```

\$PWD refers to the current folder the shell is in. If you now navigate away to a new folder, `lscurrent` lists the files in the new folder, whereas `lsthis` still lists the files in the folder where you were when you defined the alias.

`xargs`
собирает и вызывает команды из stgin
Нарпример, у нас есть файлы 
```
1.txt
2.txt
3.txt
```

и есть файл `filesToDelete.txt`
```
// filesToDelete.txt
1.txt 2.txt
```

Мы можем прочитать этот файл и для каждого слова из этого файла вызвать команду rm
`cat filesToDelete.txt | xargs rm`

Почему не работает просто pipe (`|`), потому что пайп он подменяет stdin, а названия файлов для rm это именно аргументы команды, а не stdin


`ln`
Создает ссылки на файл
существует 2 вида ссылок: Hard Link и Symbolic Link

Links  связаны с оригинальным файлом. Меняя что-то в link мы меняем и оригинальный файл 
и наоборот
Пример:

```
echo "Original content" > original.txt
cat original.txt
// Original content

ln original.txt hardlink.txt
cat hardlink.txt

echo "more stuff" >> original.txt
cat hardlink.txt
// Original content
// more stuff

echo "one more stuff" >> hardlink.txt
cat original.txt
// Original content
// more stuff
// one more stuff

```
При удалении hardlink оригинальный файл не удаляется,  тоже самое при удалении оригинального файла hardlink не удалится. *Они ссылаются на одну и ту же область памяти*

При удалении же оригинального файла, symbolic link не удалится, но перестанет ссылаться куда либо. При обращении к нему через cat получим ошибку `cat: symlink.txt: No such file or directory`. Symlinks ссылаются именно на файл


`who`
Показывает всех залогиненых пользователей

`su` залогинится в другого пользователя

`chown <user>:<group> <filename>` - поменять овнера файла/директории. `-R`  для директорий (рекурсивно)

filePermisions

`----------`
первый символ -- тип файла:
`-` regular file
`d`  directory
`l` symlink
`c` character special file

следующие 3 для для file owner
`r` - read
`w` - write
`x` - execute

следующие 3 для группы
следующие 3 для всех остальных

Если для директории не будет права `x`, то нельзя будет войти в эту директорию используя `cd dirName

`chmod` используется для смены прав для файла
```
chmod u=rwx,g=rx,o=rx filename
```

```
chmod u+x,g-x,o-wx filename // добавить или убрать пермишены
```

```
chmod a=rwx filename // поставить пермишены для всех
```

Так же можно устанавливать права числами:
`chmod 777 1.txt`

где каждая цифра это 3битное значение прав:

| двоичная | восьмеричная | символьная | права на файл       | права на каталог                   |
| -------- | ------------ | ---------- | ------------------- | ---------------------------------- |
| 000      | 0            | ---        | нет                 | нет                                |
| 001      | 1            | --x        | выполнение          | чтение свойств файлов              |
| 010      | 2            | -w-        | запись              | нет                                |
| 011      | 3            | -wx        | запись и выполнение | всё, кроме получения имени файлов  |
| 100      | 4            | r--        | чтение              | чтение имён файлов                 |
| 101      | 5            | r-x        | чтение и выполнение | доступ на чтение файлов/их свойств |
| 110      | 6            | rw-        | чтение и запись     | чтение имён файлов                 |
| 111      | 7            | rwx        | все права           | все права                          |

