
Алгоритм, который используется при передаче объектов в воркер и тд.

Его отличие от поверхностного копирования в том, что копируются свойства вложенных объектов.

Лучше, чем `JSON.parse(JSON.stringify(obj))
так как может клонировать циклические ссылки:


```js
const obj = {
    a: {
        x: 1,
        y: 0
    },
    b: "test",
};
obj.self = obj;

```


```js
JSON.stringify(obj) 

// Uncaught TypeError: Converting circular structure to JSON
```



```js
const obj_1 = structuredClone(obj)

obj_1 === obj // false

obj_1.a === obj.a // false


obj_1.self === obj_1 // false
```

Прототипы будут отбрасываться:

```js
Object.setPrototypeOf(obj, {isProto: true})

obj.isProto // true

Object.getPrototypeOf(obj) === Object.prototype // false

const obj_2 = structuredClone(obj)

Object.getPrototypeOf(obj_2) === Object.prototype // true

Object.getPrototypeOf({}) === Object.prototype // true

```


Позволяет клонировать встроенные объекты типа
- `Date` (сохраняется как есть)
- `RegExp` (клонируется с теми же флагами и паттерном)
- `Array`
- `Map`
- `Set`
- `Error`
 - `Blob`
 - `File`
и тд: (https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)


```js
const regObj = new RegExp(/test/)

const regObj_2 = structuredClone(regObj)

regObj_2 === regObj // false

regObj_2.test('test') // true

```


### Transferable objects
это специальные типы объектов, которые могут быть переданы из одного контекста выполнения (например, основного потока) в другой (например, Web Worker) без копирования их содержимого. Объект после передачи становится недоступным в исходном контексте. (https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects)

мы создаем [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)и затем клонируем объект, членом которого он является, передавая буфер. Мы можем использовать буфер в клонированном объекте, но если мы попытаемся использовать исходный буфер, мы получим исключение.

```javascript
// Create an ArrayBuffer with a size in bytes
const buffer1 = new ArrayBuffer(16);

const object1 = {
  buffer: buffer1,
};

// Clone the object containing the buffer, and transfer it
const object2 = structuredClone(object1, { transfer: [buffer1] });

// Create an array from the cloned buffer
const int32View2 = new Int32Array(object2.buffer);
int32View2[0] = 42;
console.log(int32View2[0]);

// Creating an array from the original buffer throws a TypeError
const int32View1 = new Int32Array(object1.buffer);
```


### SharedArrayBuffer
Позволяет разделять память между потоками, при этом данные в SharedArrayBuffer могут одновременно использоваться в нескольких потоках без копирования.

Для безопасного чтения и изменения данных используются `Atomics`

```js
// main.js
const sharedBuffer = new SharedArrayBuffer(4);
const sharedArray = new Int32Array(sharedBuffer);

sharedArray[0] = 0;

const worker = new Worker('worker.js');

worker.postMessage(sharedBuffer);

worker.onmessage = () => {
    const result = Atomics.load(sharedArray, 0);
    console.log('After worker', result);
};

// worker.js
onmessage = function(e) {
    const sharedBuffer = e.data;
    const sharedArray = new Int32Array(sharedBuffer);

    Atomics.add(sharedArray, 0, 1);

    postMessage('done');
};
```

Если бы несколько воркеров одновременно писали в один и тот же буфер без `Atomics`, могли бы возникнуть состояния гонки (**race conditions**). `Atomics` гарантируют, что операции чтения и записи происходят **атомарно** — то есть без перерыва и вмешательства других потоков.


Links:
https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
https://www.dev-notes.ru/articles/deep-copying-using-structured-clone/
https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone
https://github.com/tc39/proposal-ecmascript-sharedmem/blob/main/TUTORIAL.md
https://hacks.mozilla.org/2016/05/a-taste-of-javascripts-new-parallel-primitives/
https://www.youtube.com/watch?v=lxHudbhgfy0&t=3750s&ab_channel=TimurShemsedinov