Абстрактный тип данных куча (пирамида). Иногда называют очередь с приоритетом

Структура данных типа дерева,  которая удовлетворяет свойству кучи: если 
**B** является узлом-потомком (лежит ниже) узла **A** , то `k(A) >= k(B)`, где `k(X)` - ключ (идентификатор) узла.

Из этого следует, что элемент с наибольшим значением ключа всегда является корневым узлом кучи

Пример:

```
               23
        17              5
     10        5    3       2
  4     1   2
```

индексы для каждого узла проставляются сверху и слева, то есть:

```
                i0
         i1           i2
    i3       i4    i5    i6
 i7    i8  i9
```


Как видно, не обязательно, если на значение лежит на уровень ниже, оно меньше, чем значения на уровне выше (10 на i3 и 5 на i2), но оно точно меньше своего потомка

Зная индекс узла, можно найти индексы его детей по формуле:
left - `id*2 + 1`
right - `id*2 + 2`

Зная id потомка, можно найти id родителя по формуле:
`Math.floor((id - 1) / 2)`

Таким образом, мы можем отрисовать нашу кучу в виде массива:
`[23, 17, 5, 10, 5, 3, 2, 4, 1, 2]`

Высота кучи - **H** (кол-во "уровней")
Находится по формуле `H = Math.floor(Math.log2(N))`, где N - кол-во элементов в куче

## Операции
### SiftUp()
Предположим, в текущую пирамиду добавляется элемент `18`

```
                  23⁰
          17¹               5²
     10³        5⁴       3⁵     2⁶
  4⁷     1⁸   2⁹  18¹⁰
```

Как видно, он должен стать на индекс i1, 17 переедет на индекс i4, а 5 на i10
Данная операция называется `Sift Up`

```
function siftUp(arr, id){
	// id = ¹⁰
	while(id > 0){
		const current = arr[id]; // 18
		const parentId = Math.floor((id - 1) / 2); // ⁴
		const parent = arr[parentId]; // 5
		
		if(parent >= current){
			break
		}

		swap(arr, id, parentId) // меняем местами 5 и 18
		id = parentId; // меняем индекс на 4 и перепроверяем еще раз
	}
}
```

После первой итерации мы имеем кучу вида:
```
                  23⁰
          17¹               5²
     10³        18⁴       3⁵     2⁶
  4⁷     1⁸   2⁹  5¹⁰
```

Тут мы смело можем идти вверх, и не будем перепроверять нижнего левого потомка, так как он точно будет ниже текущего

##### Асимтотика SiftUp:
В худшем случае, если придется проталкивать самый большой элемент снизу вверх, придется сделать **H** операций
`T(N) = O(H) = O(logN)` *T - время выполнения* 
`M(N) = O(1)` M - использование памяти. Так как дополнительная память не используется, 


### SiftDown()
```
             7⁰
        15¹        8²
     1³   9⁴   3⁵     4⁶
```

Мы видим, что 7 стоит не на своей позиции, и нам нужно ее опустить вниз.

Для этого, нужно найди максимального ребенка и переместится на его позицию

```
function siftDown(arr, id){ 
	// id - позиция элемента, который будем спускать вниз
	const N = arr.length;
	
	while(id < N){
		const lChildId = id*2 + 1;
		const rChildId = lChildId + 1;
		
		const lChild = arr[lChildId];
		const rChild = arr[rChildId];

		let maxId = id;
		if(lChildId < N && lChild > arr[maxId]){
			// lChildId < N это проверка, что такой child существует
			maxId = lChildId;
		}
		
		if(rChildId < N && rChild > arr[maxId]){
			maxId = rChildId;
		}
		
		if(id === maxId){
			break
		}
		
		swap(arr, id, maxId);
		id = maxId
	}
}

```

После первой итерации мы имеем:
```
             15⁰
        7¹        8²
     1³   9⁴   3⁵     4⁶
```
На следующей итерации 7 и 9 поменяются местами и запустит еще одну итерацию, которая будет последней
##### Асимтотика SiftDown:
`T(N) = O(H) = O(logN)`
`M(N) = O(1)`

### ExtractMax()

```
             15⁰
        9¹        8²
     1³   7⁴   3⁵     4⁶
```

Нам нужно забрать самый большой элемент из кучи, для этого:
1. меняем местами 0 и N - 1
```
             4⁰
        9¹        8²
     1³   7⁴   3⁵     15⁶
```
2. Убираем N - 1 элемент:
```
             4⁰
        9¹        8²
     1³   7⁴   3⁵
```
3. Для 0 запускаем SiftDown:
```
             9⁰
        4¹        8²
     1³   7⁴   3⁵
```

```
             9⁰
        7¹        8²
     1³   4⁴   3⁵
```

```
function extractMax(arr){
	let N = arr.length;
	swap(arr, 0, N - 1);
    const el = arr.pop()
	siftDown(arr, 0);
    return el
}
```

##### Асимтотика ExtractMax:
`T(N) = O(H) = O(logN)`
`M(N) = O(1)`

### buildHeap(arr)
Мы имеем какой-то обычный, неотсортированный массив:
`[6, 1, 3, 2, 8, 7, 4, 0, 9, 5]`;

Возьмем образное дерево, где элементы без детей обозначим 1, а с детьми 0:

```
	         0⁰
        0¹        0²
     0³   1⁴   1⁵    1⁶
  1⁷
```

Так как это двоичное дерево, у нас элементов без детей будет примерно равно элементам с детьми

```
	          0
        0              0
     0      0      0       0
  1   1   1   1  1   1   1    1
```
Потому, что каждый уровень имеет на себе столько элементов, сколько было всех вместе взятых элементов до него

Окей, раскинем наш массив просто на дерево:
 ¹ ² ³ ⁴ ⁵ ⁶ ⁷ ⁸ ⁹

```
             6⁰
         1¹            3²
   2³         8⁴   7⁵     4⁶
0⁷    9⁸   5⁹  
```

И скажем, что все элементы, которые не имеют детей (0, 9, 5, 7, 4) стоят на своем месте.
А это половина из нашего массива.
А первую половину мы пропустим через siftDown, начиная с Math.floor(N / 2) - 1:

1. siftDown(4)
В данном случае, удовлетворяет, 8 стоит на своем месте.
```
             6⁰
         1¹            3²
   2³         8⁴   7⁵     4⁶
0⁷    9⁸   5⁹  
```

2. siftDown(3), тут 2 и 9 поменяются местами:
```
             6⁰
         1¹            3²
   9³         8⁴   7⁵     4⁶
0⁷    2⁸   5⁹  
```

3. siftDown(2), тут 3 и 7 поменяются местами:
```
             6⁰
         1¹           7²
   9³         8⁴   3⁵     4⁶
0⁷    2⁸   5⁹  
```
4. siftDown(1), тут 1 "просеется" на место 2:
```
                6⁰
         9¹           7²
    2³         8⁴   3⁵     4⁶
0⁷     1⁸   5⁹  
```
5. siftDown(0), тут 6 провалится до 8 
```
                9⁰
         8¹            7²
    2³         6⁴   3⁵     4⁶
0⁷     1⁸   5⁹  
```

Куча готова. `[9, 8, 7, 2, 6, 3, 4, 0, 1, 5]`
##### Асимтотика buildHeap: 
T(N) = O(N);
Доказательство: https://www.youtube.com/watch?v=w3Lid4CnhrU 54:38

### HeapSort()

Для того, чтобы получить сортированный массив из кучи, нужно вызвать N раз extractMax,
```
function heapSort(arr){
    const sorted = new Array(arr.length);
    let i = 0;
    while (arr.length > 0){
        sorted[i] = extractMax(arr);
        i++;
    }
    return sorted
}
```

##### Асимтотика HeapSort: 
Так как мы N раз вызываем extractMax, а асимптотика extractMax = logN,
то:
T(N) = O(N * LogN)


### Push
Для того, чтобы выполнить push в кучу, нам нужно добавить этот элемент в конец и выполнить для него siftUp

```
function push(arr, element) {
    arr.push(element);
    siftUp(arr, arr.length - 1)
}
```

Куча: `[9, 8, 7, 2, 6, 3, 4, 0, 1, 5]`
```
                9⁰
         8¹             7²
    2³         6⁴    3⁵     4⁶
0⁷     1⁸   5⁹   10¹⁰
```

```
                9⁰
         8¹             7²
    2³         10⁴    3⁵     4⁶
0⁷     1⁸   5⁹   6¹⁰
```

```
                9⁰
         10¹             7²
    2³        8⁴    3⁵     4⁶
0⁷     1⁸   5⁹   6¹⁰
```

```
                10⁰
         9¹             7²
    2³        8⁴    3⁵     4⁶
0⁷     1⁸   5⁹   6¹⁰
```

##### Асимтотика Push: 
Аммортизированное O(N), потому что, метод `.push` у массива работает по следующему принципу:
Предположим, у нас есть массив размером 4 элемента:
`[0, 1, 2, 3]`
И мы хотим добавить еще один элемент, то будет произведен resize для этого массива
То есть на самом деле создастся новый массив под 2N элементов и все элементы из этого массива переместятся туда, а это O(N)
`[0,1,2,3,4, , , ]`

Конечно, если мы сейчас добавим в этот массив элемент, то он встанет туда за O(1), однако, у нас оценка сверху, поэтому метод `.push` у массива имеет асимтотику O(N)
Таким образом, мы имеем:
```
function push(arr, element) {
    arr.push(element); // O(N)
    siftUp(arr, arr.length - 1) // O(LogN)
}
```
