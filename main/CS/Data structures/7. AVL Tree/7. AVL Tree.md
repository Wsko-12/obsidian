Бинарное дерево поиска, где разница высот левого и правого поддерева не более 1.


```
Node {
	value: number;
	height: number; // Высота поддерева, с вершиной Node
	left: Node;
	right: Node;
	parent: Node;
}

```

Для балансировки дерева используются вращения:

###  Малое левое вращение (Left Rotation)
Предположим, мы имеем дерево:
```
                       50⁴
              /                    \
             25²                   80⁴
           /    \             /          \
         20¹     30¹        70³          100³
                          /    \        /   \
                       60²      75¹    90²   120²
                       /               /       \
                     55¹             85¹       130¹
```

разница высот между левым (25) и правым (80) поддеревом у нас |2-4| = 2,
А как указанно у AVL разница должна быть >= 1.

Нарисуем это дерево как:
```
	   A₅₀
	 /      \
 ⁿ⁻¹L₂₅    ⁿ⁺¹B₈₀
		   /     \
		  ⁿC₇₀    ⁿR₁₀₀
```

Тогда:
*h(B) - h(L) = 2*
*h(C) <= h(R)*

При малом левом вращении мы делаем:
- root правое поддерево (B), 
```
	B₈₀
	
```
- текущий root(А), становится его левым ребенком, 
```
       B₈₀
     /     
    A₅₀   
   /   \
ⁿ⁻¹L₂₅ 
```
- А его текущий левый ребенок(C) становится правым ребенком для текущего root (A) 
```
         B₈₀
        /     
       A₅₀   
     /    \
 ⁿ⁻¹L₂₅    ⁿC₇₀


```
- Ну и правый ребенок у B остается как был:
```
            B₈₀
         /      \
       A₅₀      ⁿR₁₀₀
     /    \
   ⁿ⁻¹L₂₅   ⁿC₇₀
```


Проставим высоты:
```
	   A₅₀                                     B₈₀
	 /      \                               /      \
 ⁿ⁻¹L₂₅    ⁿ⁺¹B₈₀             ->         ⁿ⁺¹A₅₀      ⁿR₁₀₀
		   /     \                      /    \
		  ⁿC₇₀    ⁿR₁₀₀               ⁿ⁻¹L₂₅   ⁿC₇₀


```

и теперь видим, что высота левого поддерева (А) = n+1, а правого (R) = n,
То есть их разница = 1

У нас было условие
h(C) <= h(R), где h(C) === h(R),
Если бы оно было h(C) < h(R)
У нас бы высота правого левого поддерева была бы n, разница левого и правого была бы 0:

```
             B₈₀
          /      \
       ⁿA₅₀      ⁿR₁₀₀
      /    \
    ⁿ⁻¹L₂₅  ⁿ⁻¹C₇₀
```

Получается, наше дерево
```
                       50⁴
              /                    \
             25²                   80⁴
           /    \             /          \
         20¹     30¹        70³          100³
                          /    \        /   \
                       60²      75¹    90²   120²
                       /               /       \
                     55¹             85¹       130¹
```

Повернулось как:
```
                                80⁴
                        /               \
                     50⁴                 100³
                  /      \              /   \
              25²         70³         90²   120²
            /    \      /    \        /       \
          20¹     30¹  60²   75¹    85¹       130¹      
                      /
                    55¹           
```


###  Большое левое вращение (Big Left Rotation)
Выполняется при условии:
h(B) - h(L) = 2
h(C) > h(R),

Почти такое же дерево, но немного подрезано правое поддерево (100)
```
                       50⁴
              /                    \
             25²                   80⁴
           /    \             /          \
         20¹     30¹        70³          100²
                          /    \        /   \
                       60²      75¹    90¹   120¹
                       /               
                     55¹            

```

```
	   A₅₀
	 /      \
 ⁿ⁻¹L₂₅    ⁿ⁺¹B₈₀
		   /     \
		  ⁿC₇₀   ⁿ⁻¹R₁₀₀
```

Дополнительно добавим поддеревья M и N:
```
	   A₅₀
	 /      \
 ⁿ⁻¹L₂₅    ⁿ⁺¹B₈₀
		   /     \
		  ⁿC₇₀   ⁿ⁻¹R₁₀₀
         /   \
     ⁿ⁻¹M₆₀    ⁿ⁻¹N₇₅
```

Неправильный пример: 
Если выполнить тут просто малое вращение, то получится опять же разница высот 2:
h(A) - h(R) = 2
```
             B₈₀
          /      \
       ⁿ⁺¹A₅₀      ⁿ⁻¹R₁₀₀
      /     \
    ⁿ⁻¹L₂₅  ⁿC₇₀
            /   \
	   ⁿ⁻¹M₆₀    ⁿ⁻¹N₇₅
```

Вернемся к правильному примеру.
Имеется дерево:
```
	   A₅₀
	 /      \
 ⁿ⁻¹L₂₅    ⁿ⁺¹B₈₀
		   /     \
		  ⁿC₇₀   ⁿ⁻¹R₁₀₀
         /   \
     ⁿ⁻¹M₆₀    ⁿ⁻¹N₇₅
```

Нам нужно все подвесить к вершине C:
- Делаем вершину C корнем:
```
    C₇₀
```

У нас остаются "обрубки":
```
    /      \              A₅₀
ⁿ⁻¹M₆₀   ⁿ⁻¹N₇₅          /     \  
                    ⁿ⁻¹L₂₅   ⁿ⁺¹B₈₀
                             /    \
                                 ⁿ⁻¹R₁₀₀
```        
- Бывшего родителя (B) подвешиваем как правого ребенка (потому что оно точно больше):
```
    C₇₀
      \
     ⁿ⁺¹B₈₀
     /     \ 
          ⁿ⁻¹R₁₀₀
```
- Этому родителю(B) на место левого ребенка, откуда вырезали данную вершину ставим правого бывшего правого ребенка(N)
```
    C₇₀
      \
        B₈₀
      /     \  
 ⁿ⁻¹N₇₅      ⁿ⁻¹R₁₀₀
```
-  Новому корню(C) слева подвешиваем бывший root(A)
```
                     C₇₀
                 /         \
               A₅₀         B₈₀
             /   \        /     \
         ⁿ⁻¹L₂          ⁿ⁻¹N₇₅   ⁿ⁻¹R₁₀₀
```

- Ну и ему(A) на место правого ребенка подвешиваем бывшего левого ребенка:
```
					C₇₀
			 /             \
		  ⁿA₅₀               ⁿB₈₀
		 /     \          /       \
	 ⁿ⁻¹L₂     ⁿ⁻¹M₆₀    ⁿ⁻¹N₇₅  ⁿ⁻¹R₁₀₀
```

Пример на дереве:
```
                        50⁴
              /                    \
             25²                   80⁴
           /    \             /          \
         20¹     30¹        70³          100²
                          /    \        /   \
                       60²      75¹    90¹   120¹
                       /
                     55¹
         
```

```
70
```

```
                 70
                   \
                    80³
                  /    \
                       100²
                      /   \
                     90¹   120¹
```

```
                 70
                   \
                    80³
                  /    \
                75¹    100²
                      /   \
                     90¹   120¹
```

```
                 70
             /      \
          50³          80³
        /    \        /    \
      25²           75¹    100²
    /    \                /   \
   20¹    30¹          90¹    120¹
```

```
                    70
               /           \
            50³             80³
        /        \          /    \
      25²        60²      75¹    100²
    /    \      /               /    \
 20¹     30¹   55¹            90¹     120¹
```


###  Малое Правое вращение (Right Rotation)


```
                          50⁴
                 /                  \
                25⁴                 80²
             /       \            /     \
           20³        30²       70¹     100¹
        /   \       /
       10²   22¹   27¹
      /  \
    5¹    15¹

```


```
              A₅₀
           /      \
        ⁿ⁺²B₂₅     ⁿR₈₀
         /  \
     ⁿ⁺¹L₂₀    ⁿC₃₀
```

Выполняется при условии:
*h(B) - h(R) = 2*
*h(L) >= h(C)*

Выполняется аналогичный поворот:
- левое поддерево (B) становится корнем:
```
 B₂₅
```

- Его правым ребенком становится бывший корень (А):
```
         B₂₅
           \
            A₅₀
           /   \
                ⁿR₈₀
```
- На место "пропавшего" ребенка у бывшего корня (A) становится правый ребенок B
```
         B₂₅
           \
            A₅₀
           /   \
         ⁿC₃₀   ⁿR₈₀
```
- Ну и левый ребенок остается как и был:
```
         B₂₅
      /      \
  ⁿ⁺¹L₂₀    ⁿ⁺¹A₅₀
             /   \
           ⁿC₃₀   ⁿR₈₀
```


```
   25⁴
```

```
  25⁴
      \
       50³
      /   \
           80²
         /     \
       70¹     100¹
```

```
     25⁴
        \
         50³
      /      \
    30²      80²
   /       /     \
 27¹     70¹     100¹
```

```
                 25⁴
              /        \
           20³           50³
        /   \          /      \
       10²   22¹     30²      80²
      /  \          /       /     \
    5¹    15¹     27¹     70¹     100¹

```

###  Большое правое вращение (Big Right Rotation)

```
                       50⁴
                 /            \
                25⁴            80²
             /       \       /     \
           20²        30³  70¹     100¹
         /   \       /   \
       10¹   22¹   27²    35¹
                  /
                 26¹
```

```
              A₅₀
           /      \
        ⁿ⁺²B₂₅     ⁿR₈₀
         /    \
       ⁿL₂₀  ⁿ⁺¹C₃₀
```

Выполняется при условии:
*h(B) - h(R) = 2*
*h(L) < h(C)*

```
              A₅₀
           /      \
        ⁿ⁺²B₂₅     ⁿR₈₀
         /    \
       ⁿL₂₀  ⁿ⁺¹C₃₀
              /    \
            ⁿM₂₇    ⁿN₃₅
```

- Вершина C становится корнем:
```
C₃₀
```

Обрубки:

```
              A₅₀
           /      \
        ⁿ⁺²B₂₅     ⁿR₈₀
         /    \
       ⁿL₂₀  



              /    \
            ⁿM₂₇    ⁿN₃₅
```
- Бывший родитель(B) становится левым ребенком:
```
        C₃₀
      /
  ⁿ⁺²B₂₅
    /   \ 
  ⁿL₂₀

```
- На место пропавшего ребенка у бывшего родителя(B) становится левый ребенок:
```
        C₃₀
      /
   ⁿ⁺²B₂₅
    /   \
  ⁿL₂₀   ⁿM₂₇
```
- Бывший корень (A) идет вправо:
```
           C₃₀
      /          \ 
   ⁿ⁺²B₂₅         A₅₀  
    /   \       /    \
  ⁿL₂₀   ⁿM₂₇         ⁿR₈₀

```
- На место его утерянного ребенка идет правый ребенок:
```
           C₃₀
      /          \ 
   ⁿ⁺²B₂₅         A₅₀  
    /   \       /    \
  ⁿL₂₀   ⁿM₂₇  ⁿN₃₅   ⁿR₈₀
```

```
                       50⁴
                 /            \
                25⁴            80²
             /       \       /     \
           20²        30³  70¹     100¹
         /   \       /   \
       10¹   22¹   27²    35¹
                  /
                 26¹


```

```
30³
```

```
             30
             /
           25 
          /   \  
        20²    
       /   \   
    10¹     22¹ 

```

```
                 30
                /
               25 
          /         \  
        20²         27²
       /   \       /
    10¹     22¹  26¹

```

```
                     30
               /           \
             25            50
          /      \       /     \
        20²       27²          80²
       /   \      /         /      \
    10¹     22¹  26¹      70¹      100¹

```

```
                     30
               /           \
             25³            50³
          /      \         /     \
        20²       27²    35¹     80²
       /   \      /             /     \
    10¹     22¹  26¹           70¹   100¹

```


### Код

Так как мы постоянно ссылаемся на `node.height` и тд, а node может быть null,
то добавим вспомогательную функцию

```javascript
height(node){
	return node?.height ?? 0
}
```

Функция, которая делает пересчет высот
```javascript
fixHeight(node){
	const lh = fixHeight(node.left);
	const rh = fixHeight(node.right);

	const h = Math.max(lh, rh) + 1;
	node.heigth = h;

	return h;
}
```

Вспомогательная функция, которая поможет нам понять, использовать левое или правое вращение:

```javascript
function bFactor(node){  
	return height(node.left) - height(node.right);
}
/*
* Для определения малое это или большое, вспоминаем случаи:
*   LEFT        RIGHT
*     A           A
*   /   \       /   \
*  L     B     B     R
* Left:  h(B) - h(L) = 2
* Right: h(B) - h(R) = 2
*
* Заменим B на L или R:
* Left: h(R) - h(L) = 2 -> -h(R) + h(L) = -2 -> h(L) - h(R) = -2 -> bFactor(node) = -2; 
* Right: h(L) - h(R) = 2 -> bFactor(node) = 2;
*
* Если |bFactor(node)| = 2,
* Прокидываются дети этой ноды, чтобы определить, нужно малое или большое:
*   LEFT            RIGHT
*     A               A
*   /   \           /   \
*  L     B         B     R
*       /  \     /  \
*      C    R   L    C
*
* h(C) <= h(R) - LEFT SMALL
* h(C) > h(R) - LEFT BIG
*
* h(L) >= h(C) - RIGHT SMALL
* h(L) < h(C) - RIGHT BIG
*
* Заменим C на R и L соответсвенно:
* h(L) <= h(R) -> bFactor(node) === 0 | -1 (SMALL)
* h(L) > h(R) -> bFactor(node) === 1 (BIG)
*
* h(L) >= h(R) -> bFactor(node) === 1 | 0 (SMALL)
* h(L) < h(R) -> bFactor(node) === -1 (BIG)
* */
```


```javascript
balance(node){
	const sideFactor = bFactor(node);

	if(sideFactor === -2){ // Left
		const sizeFactor = bFactor(node.right);
		sizeFactor > 0 ? lr(node) : blr(node);
	}

	if(sideFactor === 2){ // Right
		const sizeFactor = bFactor(node.left);
		sizeFactor >= 0 ? rr(node) : brr(node);
	}
}
```

```javascript
lr(node){
	//      A                              B
	//    /  \                           /   \
	//   L    B             ->          A     R
	//       /  \                      /  \
	//	    C    R                    L    C
	
	const A = node;
	const L = node.left;
	const B = node.right;
	const C = B.left;
	
	// B
	const newRoot = B; 
	B.parent = A.parent;
	
	//      B
	//     /     
	//    A   
	//   / \
	//  L 
	B.left = A;
	A.parent = B;
	
	//       B
	//      /     
	//     A   
	//   /   \
	//  L     C
	
	A.right = C;
	C.parent = A;
	
	
	// B.right = R не делаем, так как там ничего не поменялось
	fixHeight(newRoot);
	
	return newRoot;
}
```



-  Новому корню(C) слева подвешиваем бывший root(A)
```
                     C₇₀
                 /         \
               A₅₀         B₈₀
             /            /     \
         ⁿ⁻¹L₂          ⁿ⁻¹N₇₅      ⁿ⁻¹R₁₀₀
```

- Ну и ему(A) на место правого ребенка подвешиваем бывшего левого ребенка:
```
					C₇₀
			 /             \
		  ⁿA₅₀               ⁿB₈₀
		 /     \          /       \
	 ⁿ⁻¹L₂     ⁿ⁻¹M₆₀    ⁿ⁻¹N₇₅  ⁿ⁻¹R₁₀₀
	
```

```javascript
blr(node){
	//        A                                    C
	//     /      \                             /     \
	//    L         B                          A       B
	// 	          /   \            ->        /   \    /   \
	// 	         C     R                    L     M  N     R 
	//         /   \
	//        M     N
	
	const A = node;
	const L = node.left;
	const B = node.right;
	const R = B.right;
	const C = B.left;
	const M = C.left;
	const N = C.right;
	
	// C
	const newRoot = C;
	C.parent = A.parent;
	
	//    C
	//     \
	//      B
	//     /  \ 
	//         R
	
	C.right = B;
	B.parent = C;
	
	//   C
	//    \
	//     B
	//   /   \  
	//  N     R
	
	B.left = N;
	N.parent = B;
	
	 //           C
	 //         /    \
	 //       A       B
	 //     /  \    /   \
	 //    L       N     R
	
	C.left = A;
	A.parent = C;
	
	 //           C
	 //         /    \
	 //       A       B
	 //     /  \    /   \
	 //    L    M  N     R
	
	A.right = M;
	M.parent = A;
	
	
	fixHeight(newRoot);
	return newRoot;
}


```

RR и BRL Аналогично

TODO:
Instert, Remove