Структура данных, которая позволяет хранить пары key - value.

В JS таблицу можно представить в качестве массива:

```
const hashTable = new Array(10);
```

Тогда, если мы хотим добавить какое-то значение в таблицу, мы должны высчитать хеш (index) этого value:

```
const hash = (value) => index;
```

Представим, что мы храним числа, тогда наша функция для расчета хеша будет выглядеть примерно так:

```
const hash = (value: number) => value % hashTable.length
```

Как можно заметить, у значений `1` и `11` при `length` таблицы = `10` хэши будут одинаковые, это называются коллизии.


### Разрешение коллизий в хеш-таблицах

#### Открытая адресация
Если при попытке добавить данные в хеш-таблицу мы получаем хеш (index) уже занятой ячейки, то просто увеличивается число:

##### Линейно:
```javascript
put(value){
	let index = hash(value);

	while (this.keys[index] !== null && this.keys[index] !== key) {
		index = (index + 1) % this.size;
	}

	this.keys[index] = key;
	this.values[index] = value;
}
```

##### Квадратично
```javascript
	put(key, value) {
		let index = hash(key);
		let attempt = 0;
	
		while (this.keys[index] !== null && this.keys[index] !== key) {
			attempt++;
			index = (index + attempt * attempt) % this.size;
		}
	
		this.keys[index] = key;
		this.values[index] = value;
	}
```

Если будет добавлено много элементов, которые будут давать одинаковый хеш, то скорость вставки и поиска может составить O(n).  Это явления называется **кластеризацией**, особенно при использовании линейного пробирования. То есть создаются "кластеры" — длинные последовательности занятых ячеек.

В таких ситуациях можно использовать механизм рехеширования, то есть увеличение размера таблицы и пересчет хешей всех значений в таблице.

Тогда появляется проблема при удалении. Что если мы добавили элементы a,b,c,d в таблицу, который давали одинаковые хеши. Предположим, мы пользовались линейной открытой адресацией и наши элементы стали как:

```
n+0: A
n+1: B
n+2: C
n+3: D
```

А теперь нужно удалить C, поэтому просто очищаем ячейку для C:
```
n+0: A
n+1: B
n+2: null
n+3: D
```

Но теперь, если выполнять поиск элемента D, таблица вернет false, так как алгоритм дойдет до первой свободной ячейки, а если он дошел до свободной ячейки, то элемента в таблице нет.

Поэтому, удаление из таблицы делается только тем, что ячейке устанавливается флаг deleted
```
n+0: A
n+1: B
n+2: C deleted
n+3: D
```

И таким образом можно будет дойти до элемента D.

Вместо deleted элементов можно подставлять новые.
Но при этом, нужно пройти ниже бывшего C, чтобы убедится, что не создадутся дубликаты
к примеру, мы добавляем F
```
n+0: A
n+1: B
n+2: F
n+3: D
```


#### Метод цепочек
При методе цепочек в таблице хранится не значение, а двусвязаный список.
То есть при коллизии, мы в данный список по индексу добавляем еще один элемент.

В таком случае асимтотика:

find: `table[key].find(value)` - O(k), где k - кол-во элементов в цепочке
remove: `table[key].remove(value)` - O(k), где k - кол-во элементов в цепочке
insert: `table[key].insert(value)` - O(1), если не нужно проверять на дублирование и O(k), если сначала находим, если такой элемент в цепочке

В большинстве случаев k - маленькое число, поэтому асимпотика хеш таблиц будет стремится к константному времени выполнения


### Хеширования:

Для чисел:
- Метод деления: 
```javascript
const hash = (value) => value % table.size 
```
- Метод умножения:
```javascript

const A = (Math.sqrd(5) - 1) / 2; // константа Кормена
const m = table.size
const hash = (value) => Math.floor(m * (A * value))
```

Для строк:
- Полиминальное хеширование
```javascript
const p = number;
const x = number;


```