

 **[Квантор всеобщности](https://ru.wikipedia.org/wiki/%D0%9A%D0%B2%D0%B0%D0%BD%D1%82%D0%BE%D1%80_%D0%B2%D1%81%D0%B5%D0%BE%D0%B1%D1%89%D0%BD%D0%BE%D1%81%D1%82%D0%B8 "Квантор всеобщности")** (обозначение: ∀![{\displaystyle \forall }](https://wikimedia.org/api/rest_v1/media/math/render/svg/bfc1a1a9c4c0f8d5df989c98aa2773ed657c5937), читается: «для любого…», «для каждого…», «для всех…» или «каждый…», «любой…», «все…»).

*∀x > 0 (Для любого x, больше нуля)*

 **[Квантор существования](https://ru.wikipedia.org/wiki/%D0%9A%D0%B2%D0%B0%D0%BD%D1%82%D0%BE%D1%80_%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F "Квантор существования")** (обозначение: ∃![{\displaystyle \exists }](https://wikimedia.org/api/rest_v1/media/math/render/svg/77ed842b6b90b2fdd825320cf8e5265fa937b583), читается: «существует…» или «найдётся…»).

*∃x > 0 (Существует x больше нуля)*

 **[Квантор единственности](https://ru.wikipedia.org/wiki/%D0%95%D0%B4%D0%B8%D0%BD%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C)** (обозначение: !, читается: «…является единственным»). 
 
 *∃!x > 0 (Найдется всего едиственный х, который больше нуля)*

# **f = O(g)**

f и g это функции.


Говорят, что f = O(g), если:
- ∃c > 0 (существует константа *с* положительная)
- ∃N > 0 (существует N больше 0)
- ∀n > N для любого n больше чем N
- выполняется условие f(n) <= cg(n)
Еще раз, опеределние:

**Eсли существует *c* и существует *N*, где любой *n* > N и при этом f(n) <= cg(n), то функция f = O(g)**

Таким образом, мы устанавливаем верхнюю границу.

Предположим:
`g(n) => n**2`
`f(n) => 2n`

функция, которая возводит число в квадрат, явно будет расти быстрее, чем умножает число на 2, нарисуем их:
g - синяя
f - зеленая

![[CS/Algorithms/1. Асимтотический анализ/1.png]]

Как видим, при n = 1, наша g будет давать значение меньше чем f, однако:
у нас существует такое N, при котором любой n > N функция f(n) будет давать значение ниже, чем cg(n)

То есть предположим, у нас:
`g(n) => 1`
`f(n) => 1 / x`

![[CS/Algorithms/1. Асимтотический анализ/2.png]]

То есть наша функция f = O(1), потому что существует такая N и с, при котором при любом n > N, наша функция f(n) <= cg(n)

То есть если мы даже возьмем c = 0.5, все равно найдется такое N:

 ![[3.png]]

Окей, почему же не важны константы в O:

Напишем такое условие:

f = O(2n²)

то есть `f(n) <= c * 2 * n²,

То есть мы можем выбрать другую константу *с* -- `_с = c * 2`

тогда `f(n) <= _cg(n²)`, что значит, `f = O(n²)`


ну ок, это мы опустили констану.
А что насчет f = O(n² + n)

Тут тоже можно подвести под предыдущее, но давайте рассмотрим точнее:

`g(n) => n² + n`

f(n) = c * (n² + n)
преобразуем в `сn² + cn`
И сможем ли мы тут найти такое *_c*, чтобы можно было сказать, что
`сn² + cn` <= `_с * n²` , то есть приведя это все к O(n²)
преобразуем дальше, поделим две части на `n²`

`c + c/n <= _c`

Ок, проще некуда, начинаем подставлять числа.
допустим, `n = 1`
тогда:
`c + c <= _c`
Окей, тогда `_c` это как минимум `2с`, а лучше возьмем с запасом, то есть `_c = 3c`
смотрим дальше:
`n = 2`
`c + c/2 <= 3c`
И это тоже верно.

И теперь, можно заметить, что при увеличении n, левая часть будет уменьшаться, по сравнению с `n = 1`, а это значит, что в `O(n² + n)` это  `+ n`  можно откидывать, просто опять же ставя другую *c*

Поэтому, даже если у нас O(5n⁵ + 10n³ + 200n¹⁰), это все равнo будет равно O(n¹⁰), так как мы сможем найти такую *c*



### Практика:

Нам нужно написать и оценить алгоритм нахождения простого числа
Простое число - это число, которое имеет два делителя: 1 и само себя без остатка.

3 - простое число, а вот 4 нет. Так как помимо 1 и 4 оно имеет делитель 2.

Самая простая реализация:

```javascript
const isPrime = (n) => {
	let divisors = 0;
	for(let i = 1; i <=n; i++){
		if(n % i === 0){
            divisors++;
        }
	} 
	return divisors === 2;
}
```

Теперь дадим оценку каждой операции:
Каждая операция сравнения, присвоения, математическая равна O(1)
```javascript
const isPrime = (n) => {
	let divisors = 0;  // O(1)
	for(let i = 1; i <=n; i++){ // O(1) + O(1) + O(1)
		if(n % i === 0){ // O(1)
            divisors++; // O(1)
        }
	} 
	return divisors === 2; // O(1)
}
```

Тогда мы имеем:

*O(1) + n( (O(1) + O(1) + O(1)) + O(1) + O(1) + O(1)) + O(1) =
O(2) + n(O(6)) = O(2) + O(n * 6) = O(n * 6 + 2)

Как мы доказали выше, константы можно отбрасывать, поэтому сложность алгоритма тут равна **O(n)**

Окей, пробуем улучшить:
Зачем нам проверять на 1 и на n, если можно просто найти другие делители

```javascript
const isPrime = (n) => {
	let divisors = 0; 
	for(let i = 2; i <= n - 1; i++){ 
		if(n % i === 0){
            divisors++; 
        }
	} 
	return n != 1 && divisors === 0; 
}
```

Если оценить его то мы заметим, что мы убрали всего две итерации, то есть от прошлого это как O(n - 2), а константы нам не важны, поэтому алгоритм все еще **O(n)**


Окей, рассмотрим числа 8 и 16

8:
делители:
/ 1 =  8
 / 2 = 4
-
/ 4 = 2
/ 8 = 1

Заметно, что после черты они становятся инвертироваными

16:
/ 1 = 16
/ 2 = 8
-
/ 4 = 4
-
/ 8 = 2
/ 16 = 1

Что тут для нас 4? это корень 16, поэтому, нам не имеет смысла искать делители выше, чем корень этого числа:

```javascript
const isPrime = (n) => {
	let divisors = 0; 
    const root = Math.ceil(Math.sqrt(n));
	for(let i = 2; i <= root; i++){ 
		if(n != i && n % i === 0){ // n != i for 2
            divisors++; 
        }
	} 
	return n != 1 && divisors === 0; 
}
```

Это значит, что кол-во итераций уменьшилось с n до √n, а значит, мы улучшили алгоритм до 
f = O(√n)

Вообще, почему мы сравниваем divisors с 2 в конце, если мы можем это сделать внутри цикла и прервать его раньше?

```javascript
const isPrime = (n) => {
    if(n === 1){
        return false
    }

    if(n === 2){
        return true
    }
    
	let divisors = 0; 
    const root = Math.ceil(Math.sqrt(n));
	for(let i = 2; i <= root; i++){ 
		if(n % i === 0){ // n != i for 2
            divisors++; 
        }

        if(divisors > 0){
            return false
        }
	} 
	return true; 
}
```

Да, алгоритм будет работать лучше в **некоторых** случаях, однако, тут идет оценка именно худшего случая.